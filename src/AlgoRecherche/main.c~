#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <glib.h>
#include "/usr/include/string.h"

static void supprimer_retour_ligne(char *chaine)
{
	char *p = strchr(chaine, '\r');
	if (p)
	{
		*p = 0;
	}
	/*p = strchr(chaine, '\r');
	if (p)
	{
		*p = '8';
	}*/
}


/*
* Permet d'extraire la chaine de caractère de la chaine s qui est comprise entre les positions start et end.
* Si start==end, renvoie le caractère à la position de start et end.
* Paramètres :
* 	s, la chaine de départ
*	start, la position de départ
* 	end, la position de fin
*/
char *str_sub (const char *s, unsigned int start, unsigned int end)
{
	char *new_s = NULL; //initialisation de la chaine que l'on retorunera
	//si la chaine que l'on passe n'est pas NULL et que les positions sont OK
	if (s != NULL && start <= end)
	{
		new_s = malloc (sizeof (*new_s) * (end - start + 2)); //allocation de la chaine que l'on retournera
		if (new_s != NULL)
		{
			int i; //initialise i pour la boucle for
			for (i = start; i <= end; i++)
			{
				new_s[i-start] = s[i]; //on remplit la chaine que l'on renverra
			}
			new_s[i-start] = '\0';
		}
		else
		{
			fprintf (stderr, "Memoire insuffisante\n");
			exit (EXIT_FAILURE);
		}
	}
	return new_s;
}


char* version1(char* chaine, GHashTable* table)
{
	/*int valhash =0;
	//valeur du hashage de la chaine de caractere
	valhash= g_str_hash(chaine);
	//si la valeur de hashage est dans la table
	if(g_hash_table_contains(table, valhash))
	{
		g_hash_table_lookup(table, valhash);
		return chaine;
	}
	for(int i=0; i<strlen(chaine); i++)
	{
		
	}*/
	char* substring;
	printf("Chaine de départ : %s \n",chaine);
	for(int i=0; i<strlen(chaine); i++)
	{
		for(int j=i; j<strlen(chaine); j++)
		{
			substring=str_sub(chaine,i,j);
			const int h = g_str_hash(substring);		
			printf("Sous-chaine : %s , valeur de hash : %d , taille de la chaine %d \n",substring, h, strlen(substring));	
			if(g_hash_table_contains(table, &h))
			{
				printf("OK");
			}
			
		}
	}
	return substring;
	//strcmp
}

int main()
{
	
	printf("----> Test de la HashTable <---- \n");
	//création de la table de hashage pour ranger le dico
	GHashTable* DicoHash = g_hash_table_new(g_str_hash, g_str_equal);

	int valhash = 0; //valeur de la fonction de hashage

	//Variable de l'iterateur pour la table de hashage
	GHashTableIter iter;
	char *value;
    	int *key;
	
	FILE* fichier = NULL; //definition de la variable fichier
	fichier = fopen("dico.txt","r"); //ouverture du fichier dico.txt en mode r (lecture).

	//test pour savoir si le fichier est bien ouvert
	if (fichier != NULL)
	{
		char line[128];
		while(fgets(line, sizeof line, fichier)!=NULL) //lire une ligne
		{
			supprimer_retour_ligne(line);
			printf("gstrh %d , taille %d \n",g_str_hash(line), strlen(line));
			valhash=g_str_hash(line); //récupère la valeur de la fonction de hashage

			int* tmpval=malloc(sizeof(int)); //création d'une nouvelle variable à chaque tour de boucle...
			*tmpval=valhash; //...qui contient la valeur de hashage
			
			char* tmp=malloc(strlen(line)+1); //création d'une variable à chaque tour de boucle...
			strcpy(tmp,line); //...qui contient la valeur de la ligne lue

			printf("key %d ---> %s \n", valhash, line);
			g_hash_table_insert(DicoHash, tmpval, tmp); //Insertion dans le hashtable
		}
		
		fclose(fichier); //on ferme le fichier qui à été ouvert
		
		//**** AFFICHAGE DE LA TABLE ****//
		g_hash_table_iter_init(&iter,DicoHash); //iterator pour afficher le hashtable
		while (g_hash_table_iter_next (&iter, (gpointer)&key, (gpointer)&value))
		{
			//printf("key %d ---> %s\n", *key, value);
		}
	}
	else //si le fichier n'a pas été ouvert
	{
		printf("Impossible d'ouvrir le fichier dico.txt \n");
	}

	printf("----> Test de la Version 1 <---- \n");
	char*subtring=version1("dxabaissaiz",DicoHash);
	return EXIT_SUCCESS;
}



